# -*- coding: utf-8 -*-

"""
/***************************************************************************
 flow_&_ordering
                                 A QGIS plugin
 Flow and Ordering
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-06-13
        copyright            : (C) 2022 by FALASY  Anamelechi
        email                : fvw.services@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'FALASY  Anamelechi'
__date__ = '2022-06-13'
__copyright__ = '(C) 2022 by FALASY  Anamelechi'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os, math
import inspect
from qgis.PyQt.QtGui import QIcon

from qgis.core import QgsProcessing
from qgis.core import QgsProcessingAlgorithm
from qgis.core import QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterRasterLayer
from qgis.core import QgsProcessingParameterFeatureSource
from qgis.core import QgsProcessingParameterFeatureSink
from qgis.core import QgsProcessingParameterBoolean
from qgis.core import QgsProcessingParameterVectorLayer
from qgis.core import QgsProcessingParameterNumber
from qgis.core import QgsProcessingParameterField

import processing
import sys
import csv

from PyQt5 import QtWidgets
from qgis.PyQt.QtCore import QCoreApplication, QVariant

from qgis.core import *
from collections import Counter
import time
import numpy as np


class FlowAlgorithm(QgsProcessingAlgorithm):
    INPUT_LAYER = 'INPUT_LAYER'
    FROM_FIELD = 'FROM_FIELD'
    TO_FIELD = 'TO_FIELD'        
    OUTPUT = 'OUTPUT'
    
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return FlowAlgorithm()
        
    def name(self):        
        return 'h. Network Flow Lines'

    def displayName(self):        
        return self.tr(self.name())

    def group(self):        
        return self.tr(self.groupId())

    def groupId(self):        
        return ''

    def icon(self):
        cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]
        icon = QIcon(os.path.join(os.path.join(cmd_folder, 'logo.png')))
        return icon
        
    def shortHelpString(self):
        return self.tr( """This tool uses the Line segment IDs to determine the Flow Line Route for tile networks. 
        
        Workflow:         
        1. Select a vector Line layer. This is a follow-up from "Routine G"
        2. Select the respective Field IDs that represents fields in the attribute tables of the displayed line layer
        3. Save the output file (optional)        
        4. Click on \"Run\"               
                
        The script will give out an output. 
                
        The help link in the Graphical User Interface (GUI) provides more information about the plugin.
        """)   
        
    def helpUrl(self):
        return "https://publish.illinois.edu/illinoisdrainageguide/files/2022/06/PublicAccess.pdf"


    def initAlgorithm(self, config):
        self.addParameter(QgsProcessingParameterVectorLayer(self.INPUT_LAYER, self.tr('Sound Tile Network: from Tile Network Generator'), [QgsProcessing.TypeVectorLine], defaultValue=None))                
        
        self.addParameter(QgsProcessingParameterField(self.FROM_FIELD, self.tr("Tile_From"), parentLayerParameterName = self.INPUT_LAYER, type = QgsProcessingParameterField.Any, defaultValue=None))
        
        self.addParameter(QgsProcessingParameterField(self.TO_FIELD, self.tr("Tile_To"), parentLayerParameterName = self.INPUT_LAYER, type = QgsProcessingParameterField.Any, defaultValue=None))
                
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUTPUT, self.tr('Network Flow Line')))

    def processAlgorithm(self, parameters, context, feedback):
        
        rawz_layer = self.parameterAsVectorLayer(parameters, self.INPUT_LAYER, context)
        
        if rawz_layer is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        raw_fields = rawz_layer.fields()                
        
        '''Counter for the progress bar'''
        total = rawz_layer.featureCount()
        parts = 100/total

        '''names of fields from Tile Network'''        
        from_field = self.parameterAsString(parameters, self.FROM_FIELD, context)
        to_field = self.parameterAsString(parameters, self.TO_FIELD, context)
               
        '''field index for id,next segment, previous segment'''
        idx_from = rawz_layer.fields().indexFromName(from_field) 
        idx_to = rawz_layer.fields().indexFromName(to_field)
                
        '''add new fields'''
        #define new fields
        out_fields = QgsFields()
        #append fields
        for field in raw_fields:
            out_fields.append(QgsField(field.name(), field.type()))
        out_fields.append(QgsField('FLOW_LINE', QVariant.String))
        out_fields.append(QgsField('TILE_FLOW', QVariant.String))
                
        '''load data from layer "raw_layer" '''
        feedback.setProgressText(self.tr("Loading network layer\n "))
        
        ab_map = {}
        for feature in rawz_layer.getFeatures():
            ab_to = feature[to_field]
            ab_from = feature[from_field]
            
            if ab_to not in ab_map:
                ab_map[ab_to] = [ab_from]
            else:
                ab_map[ab_to].append(ab_from)
        
        feedback.setProgressText(self.tr("Data loaded \n Calculating flow lines \n"))
        
        result1 = []
        intermediate_cache = ['Out']

        while len(result1) < total:
            intermediate_cache2 = []
            for begin in intermediate_cache:
                try:
                    for item in ab_map[begin]:
                        result1.append(item)
                        intermediate_cache2.append(item)
                except:
                    pass
            intermediate_cache = intermediate_cache2
                
        '''segments with numbers'''
        feedback.setProgressText(self.tr("Data loaded \n Calculating flow lines \n"))
        
        '''sink definition'''
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context, out_fields, rawz_layer.wkbType(), rawz_layer.sourceCrs())
                    
        '''add new features to sink'''
        feedback.setProgressText(self.tr("creating output \n"))
        features = rawz_layer.getFeatures()
        
        for (n, feature) in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break                          
            # Add a feature in the sink
            outFt = QgsFeature(out_fields)
            outFt.setGeometry(feature.geometry())
            outFt.setAttributes(feature.attributes() + [None] + [None])
            outFt["FLOW_LINE"] = result1[n]
            outFt["TILE_FLOW"] = total - result1.index(feature[from_field])
            sink.addFeature(outFt, QgsFeatureSink.FastInsert)
            
            # Update the progress bar
            feedback.setProgress(int(n * total))
       
        return {self.OUTPUT: dest_id}   
