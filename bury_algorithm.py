# -*- coding: utf-8 -*-

"""
/***************************************************************************
 flow_&_ordering
                                 A QGIS plugin
 Flow and Ordering
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-06-13
        copyright            : (C) 2022 by FALASY  Anamelechi
        email                : fvw.services@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'FALASY  Anamelechi'
__date__ = '2022-06-13'
__copyright__ = '(C) 2022 by FALASY  Anamelechi'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os, math
import inspect
from qgis.PyQt.QtGui import QIcon

from qgis.core import QgsProcessing
from qgis.core import QgsProcessingAlgorithm
from qgis.core import QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterRasterLayer
from qgis.core import QgsProcessingParameterFeatureSource
from qgis.core import QgsProcessingParameterFeatureSink
from qgis.core import QgsProcessingParameterBoolean
from qgis.core import QgsProcessingParameterVectorLayer
from qgis.core import QgsProcessingParameterNumber
from qgis.core import QgsProcessingParameterField
from qgis.core import QgsProcessingParameterEnum

import processing
import processing as st
import sys
import csv

from PyQt5 import QtWidgets
from qgis.PyQt.QtCore import QCoreApplication, QVariant

from qgis.core import *
from collections import Counter
import time
import numpy as np

class BuryAlgorithm(QgsProcessingAlgorithm):
    INPUT_LAYER = 'INPUT_LAYER'
    SEGMENT_KEY = 'SEGMENT_KEY'    
    DIST_KEY = 'DIST_KEY'
    SURFACE_KEY = 'SURFACE_KEY'    
    UPPER_KEY = 'UPPER_KEY'
    LOWER_KEY = 'LOWER_KEY'
    ABS_UPPER_KEY = 'ABS_UPPER_KEY'
    ABS_LOWER_KEY = 'ABS_LOWER_KEY'
    MAXI_SLOPE_KEY = 'MAXI_SLOPE_KEY'
    MINI_SLOPE_KEY = 'MINI_SLOPE_KEY'
    OFFSET_KEY = 'OFFSET_KEY'
    CONST_SLOPE_KEY = 'CONST_SLOPE_KEY'
    USE_CONST_KEY = 'USE_CONST_KEY'    
    OUTPUT = 'OUTPUT'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return BuryAlgorithm()
        
    def name(self):        
        return 'l. Tile Burying System'

    def displayName(self):        
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):        
        return ''

    def icon(self):
        cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]
        icon = QIcon(os.path.join(os.path.join(cmd_folder, 'logo.png')))
        return icon
        
    def shortHelpString(self):
        return self.tr( """This tool is used to determine the elevation depths for burying the entire tile networks. 
        
        Workflow:         
        1. Select a vector layer of elevation point. This is a follow-up from "Routine K"
        2. Specify the respective burying parameters
        3. Make a decision based on the field terrain using the Constant Slope Option 
        4. Save the output file (optional)        
        5. Click on \"Run\"               
                
        The script will give out an output. 
                
        The help link in the Graphical User Interface (GUI) provides more information about the plugin.
        """)   
        
    def helpUrl(self):
        return "https://publish.illinois.edu/illinoisdrainageguide/files/2022/06/PublicAccess.pdf"
        
        
    def initAlgorithm(self, config):
        self.addParameter(QgsProcessingParameterVectorLayer(self.INPUT_LAYER, self.tr('Network Elevation Points'), [QgsProcessing.TypeVectorPoint], defaultValue=None))               
        
        self.addParameter(QgsProcessingParameterField(self.SEGMENT_KEY, self.tr("Line Segments [LINE_ID]"), parentLayerParameterName = self.INPUT_LAYER, type = QgsProcessingParameterField.Any, defaultValue=None))
        self.addParameter(QgsProcessingParameterField(self.DIST_KEY, self.tr("Point Distances [DIST]"), parentLayerParameterName = self.INPUT_LAYER, type = QgsProcessingParameterField.Any, defaultValue=None))        
        self.addParameter(QgsProcessingParameterField(self.SURFACE_KEY, self.tr("Surface Elevation [SURF_ELEV]"), parentLayerParameterName = self.INPUT_LAYER, type = QgsProcessingParameterField.Any, defaultValue=None))               
        
        self.addParameter(QgsProcessingParameterNumber(self.UPPER_KEY, self.tr('Upper Tile Depth [ft]'), type=QgsProcessingParameterNumber.Double, maxValue=10.0, defaultValue=3.25))
        self.addParameter(QgsProcessingParameterNumber(self.LOWER_KEY, self.tr('Lower Tile Depth [ft]'), type=QgsProcessingParameterNumber.Double, maxValue=10.0, defaultValue=3.75))
        self.addParameter(QgsProcessingParameterNumber(self.ABS_UPPER_KEY, self.tr('Absolute Upper Tile Depth [ft]'), type=QgsProcessingParameterNumber.Double, maxValue=10.0, defaultValue=3.00))
        self.addParameter(QgsProcessingParameterNumber(self.ABS_LOWER_KEY, self.tr('Absolute Lower Tile Depth [ft]'), type=QgsProcessingParameterNumber.Double, maxValue=10.0, defaultValue=4.00))
        self.addParameter(QgsProcessingParameterNumber(self.MAXI_SLOPE_KEY, self.tr('Maximum Slope Depth [percentage]'), type=QgsProcessingParameterNumber.Double, maxValue=100.0, defaultValue=5.00))
        self.addParameter(QgsProcessingParameterNumber(self.MINI_SLOPE_KEY, self.tr('Minimum Slope Depth [percentage]'), type=QgsProcessingParameterNumber.Double, maxValue=100.0, defaultValue=0.10))
        self.addParameter(QgsProcessingParameterNumber(self.OFFSET_KEY, self.tr('Offset Depth [ft]'), type=QgsProcessingParameterNumber.Double, maxValue=10.0, defaultValue=0.00))
        
        self.addParameter(QgsProcessingParameterNumber(self.CONST_SLOPE_KEY, self.tr('Constant Slope Depth [percentage]'), type=QgsProcessingParameterNumber.Double, maxValue=100.0, defaultValue=0.50, optional = True))
        self.addParameter(QgsProcessingParameterBoolean(self.USE_CONST_KEY, self.tr('Include Constant Slope'), defaultValue=False))
                                     
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUTPUT, self.tr('Buried Elevation Depths')))
        
                      
    def processAlgorithm(self, parameters, context, feedback):                
        
        raw_layer = self.parameterAsVectorLayer(parameters, self.INPUT_LAYER, context)
        
        if raw_layer is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT))
        raw_fields = raw_layer.fields()                
        
        upper_depth = parameters[self.UPPER_KEY]
        lower_depth = parameters[self.LOWER_KEY]
        mid_depth = (upper_depth + lower_depth) / 2  # Mid-Depth Value, MD
        
        abs_upper = parameters[self.ABS_UPPER_KEY]
        abs_lower = parameters[self.ABS_LOWER_KEY]
        
        slope_mx = parameters[self.MAXI_SLOPE_KEY]
        max_slope = (slope_mx * 0.01)
        
        slope_mn = parameters[self.MINI_SLOPE_KEY]
        min_slope = (slope_mn * 0.01) 
        
        offset = parameters[self.OFFSET_KEY]
        
        const_slope = parameters[self.CONST_SLOPE_KEY]
        constant_slope = (const_slope * 0.01)
        
        const_key = parameters[self.USE_CONST_KEY]
        
        '''add new fields'''
        #define new fields
        out_fields = QgsFields()
        #append fields
        for field in raw_fields:
            out_fields.append(QgsField(field.name(), field.type()))
        out_fields.append(QgsField('ELEV_DEPTHS', QVariant.String))
        out_fields.append(QgsField('BURY_DEPTHS', QVariant.String))        
                      
        '''Counter for the progress bar'''
        total = raw_layer.featureCount()
        parts = 100/total

        '''names of fields from Tile Network'''        
        segment_id = self.parameterAsString(parameters, self.SEGMENT_KEY, context)
        dist_id = self.parameterAsString(parameters, self.DIST_KEY, context)
        surface_id = self.parameterAsString(parameters, self.SURFACE_KEY, context)
        
        '''field index for id,next segment, previous segment'''
        idx_segment = raw_layer.fields().indexFromName(segment_id) 
        idx_dist = raw_layer.fields().indexFromName(dist_id)
        idx_surface = raw_layer.fields().indexFromName(surface_id)
                        
        '''load data from layer "raw_layer" '''
        feedback.setProgressText(self.tr("Loading network layer\n "))        
        
        # first = previous; second = current
        def tile_elev(first_dist, second_dist, s_elev, start_elev):
            # Without Constant Slope
            if second_dist == first_dist:
                return start_elev

            dist_difference = second_dist - first_dist # Distance Difference Value, L3

            # Use Constant Slope
            if const_key is True:
                return start_elev + (dist_difference * constant_slope) / 100

            # Plotting with Slope Calculations
            mid_elev = s_elev - mid_depth
            tile_elev = (mid_elev - start_elev) / dist_difference   # average plot Value, asl

            if tile_elev > max_slope:
                tile_elev = start_elev + (dist_difference * max_slope)
            if tile_elev < min_slope:
                tile_elev = start_elev + (dist_difference * min_slope)
            if tile_elev > s_elev - abs_upper:
                tile_elev = s_elev - abs_upper
            if tile_elev < s_elev - abs_lower:
                tile_elev = s_elev - abs_lower

            return tile_elev

        feedback.pushInfo(QCoreApplication.translate('TempFiles','Calculating elevation depths'))                    
        
        '''sink definition'''
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context, out_fields, raw_layer.wkbType(), raw_layer.sourceCrs())
                                       
        '''add new features to sink'''
        feedback.setProgressText(self.tr("creating output \n"))
        features = raw_layer.getFeatures()

        current_line_id = None
        p_dist = None
        p_elev = None

        for (n, feature) in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break                          
            # Add a feature in the sink
            outFt = QgsFeature(out_fields)
            outFt.setGeometry(feature.geometry())
            outFt.setAttributes(feature.attributes() + [None, None])  # Expand array

            c_dist = feature[idx_dist]
            s_elev = feature[idx_surface]
            if feature[idx_segment] != current_line_id:  # newline
                current_line_id = feature[idx_segment]
                p_dist = c_dist
                p_elev = s_elev - mid_depth  # for now we just use middle value of lower and upper as the start elevation
            b_elev = tile_elev(p_dist, c_dist, s_elev, p_elev)
            outFt["ELEV_DEPTHS"] = b_elev + offset
            outFt["BURY_DEPTHS"] = s_elev - outFt["ELEV_DEPTHS"]
            p_dist = c_dist
            p_elev = b_elev

            # Add feature to sink
            sink.addFeature(outFt, QgsFeatureSink.FastInsert)                      
       
        return {self.OUTPUT: dest_id}
