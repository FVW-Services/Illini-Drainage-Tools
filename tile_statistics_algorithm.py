# -*- coding: utf-8 -*-

"""
/***************************************************************************
 RoadSlopeCalculator
                                 A QGIS plugin
 Performs Specific Draiange Related Tasks and Analysis on a Site
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------        
        begin                : 2021-03-09
        copyright            : (C) 2021 by Antonio Sobral Almeida
        email                : 66124.almeida@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Antonio Sobral Almeida'
__date__ = '2021-03-09'
__copyright__ = '(C) 2022 by Antonio Sobral Almeida'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os
import inspect
from qgis.PyQt.QtGui import QIcon

from qgis.core import QgsProcessing
from qgis.core import QgsProcessingAlgorithm
from qgis.core import QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterRasterLayer
from qgis.core import QgsProcessingParameterFeatureSink
from qgis.core import QgsProcessingParameterBoolean
from qgis.core import QgsProcessingParameterVectorLayer
from qgis.core import QgsProcessingParameterNumber

import processing

from PyQt5 import QtWidgets
from qgis.PyQt.QtCore import QCoreApplication

from qgis.core import *
from collections import Counter
import time
import numpy as np

class TileStatisticsAlgorithm(QgsProcessingAlgorithm):

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
        
    def createInstance(self):
        return TileStatisticsAlgorithm()
        
    def name(self):
        return 'j. End Point Elevations'

    def displayName(self):
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return ''
        
    def icon(self):
        cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]
        icon = QIcon(os.path.join(os.path.join(cmd_folder, 'logo.png')))
        return icon
        
    def shortHelpString(self):
        return self.tr( """This tool is used to determine the end point elevations for each line segment in network layout). 
        It Calculates the logitudinal slope of each line segment, in percentage.
        
        Workflow: 
        1. Select two layers: a DEM Layer and a Network Generated Vector Line layer (e.g. Tile Network). This is a follow-up from "Routine I"
        2. Specify a value for the line segment. This can be left at Default Value
        3. Save the output file (optional)         
        4. Click on \"Run\"
                
        Notes for Input parameters: 
        1 - Line Segment: It is advisable that the length of the segments in the selected vector line layer be equal or greater than 5 times the pixel size of the DEM. The value entered here determines the length of the line segments created.  
        2 - Digital Elevation Model (DEM): any elevation raster, with elevation values in same units as road network vector layer lengths. 
        3 - The Tile Lines: Select any vector line layer that is completely within the DEM data area. 
        
        The script will give out an output with default name as:
        \"Calculated\" -- A new line vector layer, segmented, with two new fields: 
        \"Length", with the current length of the segmentation (note that there might be residual segments, of less than the chosen length); 
        \"Slope_%", with the longitudinal slope of each segment, in percentage. 
        
        The help link in the Graphical User Interface (GUI) provides more information about the plugin.
        """)   
        
    def helpUrl(self):
        return "https://publish.illinois.edu/illinoisdrainageguide/files/2022/06/PublicAccess.pdf" 
    
    
    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterRasterLayer('MDT', 'Field DEM', defaultValue=None))
        self.addParameter(QgsProcessingParameterFeatureSink('TileStats', 'Tile Statistics', type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, supportsAppend=True, defaultValue=None))
        self.addParameter(QgsProcessingParameterBoolean('VERBOSE_LOG', 'Verbose logging', optional=True, defaultValue=True))
        self.addParameter(QgsProcessingParameterVectorLayer('VectorLineLayer', 'Tile Network Lines', types=[QgsProcessing.TypeVectorLine], defaultValue=None))
        self.addParameter(QgsProcessingParameterNumber('SegmentLength', 'Line Segment (=> 5 times pixel size)', type=QgsProcessingParameterNumber.Double, maxValue=1.79769e+308, defaultValue=5000))

    def processAlgorithm(self, parameters, context, model_feedback):
        # Use a multistep feedback, so that individual child algorithm progress reports are adjusted for the
        # overall progress through the model
        feedback = QgsProcessingMultiStepFeedback(5, model_feedback)
        results = {}
        outputs = {}

        alg_params = {
            'INPUT': parameters['VectorLineLayer'],
            'LENGTH': parameters['SegmentLength'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }

        # Check if vector line layer 'VectorLineLayer' is in geographic coordinates

        vector_layer = self.parameterAsVectorLayer(parameters, 'VectorLineLayer', context)
        if vector_layer.crs().isGeographic():

            w = QtWidgets.QWidget()
            b = QtWidgets.QLabel(w)
            w.setGeometry(400,400,800,20)
            w.setWindowTitle("Attention: vector line layers in geographic coordinates are not allowed! Ending plugin without slope calculation...")
            w.show()
            time.sleep(10)
            return results

        # Split lines by maximum length

        outputs['SplitLinesByMaximumLength'] = processing.run('native:splitlinesbylength', alg_params, context=context, feedback=feedback, is_child_algorithm=True) #1

        feedback.setCurrentStep(1)
        if feedback.isCanceled():
            return {}

        # Drape (set Z value from raster)
        alg_params = {
            'BAND': 1,
            'INPUT': outputs['SplitLinesByMaximumLength']['OUTPUT'],
            'NODATA': -9999,
            'RASTER': parameters['MDT'],
            'SCALE': 1,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['DrapeSetZValueFromRaster'] = processing.run('native:setzfromraster', alg_params, context=context, feedback=feedback, is_child_algorithm=True) #2

        feedback.setCurrentStep(2)
        if feedback.isCanceled():
            return {}

        # Extract Z values
        alg_params = {
            'COLUMN_PREFIX': 'Elev_',
            'INPUT': outputs['DrapeSetZValueFromRaster']['OUTPUT'],
            'SUMMARIES': [0,1],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['ExtractZValues'] = processing.run('native:extractzvalues', alg_params, context=context, feedback=feedback, is_child_algorithm=True) #3

        feedback.setCurrentStep(3)
        if feedback.isCanceled():
            return {}

        # Field calculator1
        alg_params = {
            'FIELD_LENGTH': 11,
            'FIELD_NAME': 'True_Length',
            'FIELD_PRECISION': 2,
            'FIELD_TYPE': 0,
            'FORMULA': ' $length ',
            'INPUT': outputs['ExtractZValues']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['FieldCalculator1'] = processing.run('native:fieldcalculator', alg_params, context=context, feedback=feedback, is_child_algorithm=True) #4

        feedback.setCurrentStep(4)
        if feedback.isCanceled():
            return {}

        # Field calculator2
        alg_params = {
            'FIELD_LENGTH': 11,
            'FIELD_NAME': 'Abs_Slope',
            'FIELD_PRECISION': 3,
            'FIELD_TYPE': 0,
            'FORMULA': '(abs(\"Elev_First\" - \"Elev_Last\") / \"length\" ) *100',
            'INPUT': outputs['FieldCalculator1']['OUTPUT'],
            'OUTPUT': parameters['TileStats']
        }
        outputs['FieldCalculator2'] = processing.run('native:fieldcalculator', alg_params, context=context, feedback=feedback, is_child_algorithm=True) #5
        results['TileStats'] = outputs['FieldCalculator2']['OUTPUT']
        return results

    
